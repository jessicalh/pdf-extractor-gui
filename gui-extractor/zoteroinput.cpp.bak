#include "zoteroinput.h"
#include <QComboBox>
#include <QPushButton>
#include <QLabel>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QMessageBox>
#include <QTemporaryFile>
#include <QFile>
#include <QDir>
#include <QPdfDocument>
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QEventLoop>
#include <QTimer>
#include <QDebug>
#include <QDateTime>
#include <QTextStream>
#include <QCoreApplication>

ZoteroInputWidget::ZoteroInputWidget(QWidget *parent)
    : QWidget(parent)
    , m_networkManager(new QNetworkAccessManager(this))
    , m_currentReply(nullptr)
    , m_isLoading(false)
    , m_logFile(nullptr) {

    setupUI();

    // Initialize log file
    QString logPath = QCoreApplication::applicationDirPath() + "/zotero.log";
    m_logFile = new QFile(logPath);

    // Open in append mode to preserve previous logs
    if (m_logFile->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
        logToFile("========================================");
        logToFile(QString("Zotero Integration Started - %1").arg(QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss")));
        logToFile("========================================");
    }

    // Load credentials from database on creation
    QSqlDatabase db = QSqlDatabase::database();
    if (db.isOpen()) {
        logToFile("Loading credentials from database...");
        QSqlQuery query(db);
        if (query.exec("SELECT zotero_user_id, zotero_api_key FROM settings LIMIT 1") && query.next()) {
            m_userId = query.value("zotero_user_id").toString();
            m_apiKey = query.value("zotero_api_key").toString();
            logToFile(QString("Credentials loaded - User ID: %1, API Key: %2").arg(
                m_userId.isEmpty() ? "NOT SET" : m_userId,
                m_apiKey.isEmpty() ? "NOT SET" : "***" + m_apiKey.right(4)));
        } else {
            logToFile("No credentials found in database");
        }
    } else {
        logToFile("Database not open - cannot load credentials");
    }
}

ZoteroInputWidget::~ZoteroInputWidget() {
    if (m_currentReply) {
        m_currentReply->abort();
        m_currentReply->deleteLater();
    }

    if (m_logFile) {
        logToFile("Zotero Integration Shutting Down");
        m_logFile->close();
        delete m_logFile;
    }
}

void ZoteroInputWidget::setupUI() {
    auto* layout = new QVBoxLayout(this);

    // Status label at top
    m_statusLabel = new QLabel("Click refresh to load your Zotero collections", this);
    m_statusLabel->setWordWrap(true);
    layout->addWidget(m_statusLabel);

    // Collections section
    auto* collectionsLayout = new QHBoxLayout();
    collectionsLayout->addWidget(new QLabel("Collection:"));

    m_collectionsCombo = new QComboBox(this);
    m_collectionsCombo->setMinimumWidth(300);
    m_collectionsCombo->addItem("Select a collection...");
    collectionsLayout->addWidget(m_collectionsCombo, 1);

    m_refreshButton = new QPushButton("ðŸ”„ Refresh", this);
    m_refreshButton->setMaximumWidth(100);
    collectionsLayout->addWidget(m_refreshButton);

    layout->addLayout(collectionsLayout);

    // Papers section
    auto* papersLayout = new QHBoxLayout();
    papersLayout->addWidget(new QLabel("Paper:"));

    m_papersCombo = new QComboBox(this);
    m_papersCombo->setMinimumWidth(400);
    m_papersCombo->addItem("Select a paper...");
    m_papersCombo->setEnabled(false);
    papersLayout->addWidget(m_papersCombo, 1);

    layout->addLayout(papersLayout);

    // Analyze button
    auto* buttonLayout = new QHBoxLayout();
    buttonLayout->addStretch();

    m_analyzeButton = new QPushButton("Analyze", this);
    m_analyzeButton->setEnabled(false);
    buttonLayout->addWidget(m_analyzeButton);

    layout->addLayout(buttonLayout);
    layout->addStretch();

    // Connect signals
    connect(m_refreshButton, &QPushButton::clicked, this, &ZoteroInputWidget::onRefreshCollections);
    connect(m_collectionsCombo, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ZoteroInputWidget::onCollectionChanged);
    connect(m_papersCombo, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ZoteroInputWidget::onPaperChanged);
    connect(m_analyzeButton, &QPushButton::clicked, this, &ZoteroInputWidget::onAnalyzeClicked);
}

void ZoteroInputWidget::setCredentials(const QString& userId, const QString& apiKey) {
    m_userId = userId;
    m_apiKey = apiKey;
}

QString ZoteroInputWidget::validate() const {
    if (m_userId.isEmpty() || m_apiKey.isEmpty()) {
        return "Zotero credentials not configured. Please set them in Settings â†’ Zotero.";
    }

    if (m_papersCombo->currentIndex() <= 0) {
        return "Please select a paper from your Zotero collection.";
    }

    if (m_downloadedPdfPath.isEmpty()) {
        return "No PDF downloaded yet. Click Analyze to download.";
    }

    return QString(); // Valid
}

void ZoteroInputWidget::reset() {
    clearCollections();
    clearPapers();
    m_downloadedPdfPath.clear();
    m_tempPdfFile.reset();
    m_statusLabel->setText("Click refresh to load your Zotero collections");
    setUIEnabled(true);
}

void ZoteroInputWidget::onRefreshCollections() {
    logToFile("User clicked Refresh Collections button");
    if (m_userId.isEmpty() || m_apiKey.isEmpty()) {
        logError("Credentials missing - showing warning dialog");
        QMessageBox::warning(this, "Configuration Required",
            "Please configure your Zotero credentials in Settings â†’ Zotero first.");
        return;
    }

    fetchCollections();
}

void ZoteroInputWidget::onCollectionChanged(int index) {
    if (index <= 0 || m_isLoading) {
        clearPapers();
        return;
    }

    if (index - 1 < m_collections.size()) {
        const auto& collection = m_collections[index - 1];
        m_currentCollectionKey = collection.key;
        fetchItemsForCollection(collection.key);
    }
}

void ZoteroInputWidget::onPaperChanged(int index) {
    m_analyzeButton->setEnabled(index > 0 && !m_isLoading);

    if (index > 0 && index - 1 < m_items.size()) {
        m_currentItem = m_items[index - 1];
    }
}

void ZoteroInputWidget::onAnalyzeClicked() {
    if (m_papersCombo->currentIndex() <= 0) {
        QMessageBox::warning(this, "Selection Required", "Please select a paper first.");
        return;
    }

    // If we haven't checked for attachments yet, fetch them first
    if (m_currentItem.hasPdf && m_currentItem.pdfAttachmentKey.isEmpty()) {
        // Need to fetch children to get attachment key
        fetchChildrenForItem(m_currentItem.key);
        return;
    }

    if (!m_currentItem.hasPdf) {
        QMessageBox::warning(this, "No PDF Available",
            "The selected item does not have a PDF attachment.");
        return;
    }

    // Download the PDF
    downloadPdf(m_currentItem.key, m_currentItem.pdfAttachmentKey);
}

void ZoteroInputWidget::fetchCollections() {
    if (m_currentReply) {
        m_currentReply->abort();
    }

    setUIEnabled(false);
    m_isLoading = true;
    m_statusLabel->setText("Loading collections...");
    emit statusMessage("Fetching Zotero collections...");

    // Clear existing data
    clearCollections();
    clearPapers();

    // API endpoint for user's collections
    QString url = QString("https://api.zotero.org/users/%1/collections").arg(m_userId);

    QNetworkRequest request{QUrl(url)};
    request.setRawHeader("Zotero-API-Version", "3");
    request.setRawHeader("Authorization", QString("Bearer %1").arg(m_apiKey).toUtf8());

    m_currentReply = m_networkManager->get(request);
    connect(m_currentReply, &QNetworkReply::finished, this, &ZoteroInputWidget::handleCollectionsReply);
}

void ZoteroInputWidget::fetchItemsForCollection(const QString& collectionKey) {
    if (m_currentReply) {
        m_currentReply->abort();
    }

    setUIEnabled(false);
    m_isLoading = true;
    m_statusLabel->setText("Loading papers...");
    emit statusMessage("Fetching papers from collection...");

    clearPapers();

    // API endpoint for items in a collection
    QString url = QString("https://api.zotero.org/users/%1/collections/%2/items")
                    .arg(m_userId)
                    .arg(collectionKey);

    QNetworkRequest request{QUrl(url)};
    request.setRawHeader("Zotero-API-Version", "3");
    request.setRawHeader("Authorization", QString("Bearer %1").arg(m_apiKey).toUtf8());
    request.setRawHeader("Content-Type", "application/json");

    m_currentReply = m_networkManager->get(request);
    connect(m_currentReply, &QNetworkReply::finished, this, &ZoteroInputWidget::handleItemsReply);
}

void ZoteroInputWidget::fetchChildrenForItem(const QString& itemKey) {
    if (m_currentReply) {
        m_currentReply->abort();
    }

    setUIEnabled(false);
    m_isLoading = true;
    m_statusLabel->setText("Checking for PDF attachments...");
    emit statusMessage("Fetching item attachments...");

    // API endpoint for item's children
    QString url = QString("https://api.zotero.org/users/%1/items/%2/children")
                    .arg(m_userId)
                    .arg(itemKey);

    QNetworkRequest request{QUrl(url)};
    request.setRawHeader("Zotero-API-Version", "3");
    request.setRawHeader("Authorization", QString("Bearer %1").arg(m_apiKey).toUtf8());

    m_currentReply = m_networkManager->get(request);
    connect(m_currentReply, &QNetworkReply::finished, this, &ZoteroInputWidget::handleChildrenReply);
}

void ZoteroInputWidget::downloadPdf(const QString& itemKey, const QString& attachmentKey) {
    if (m_currentReply) {
        m_currentReply->abort();
    }

    setUIEnabled(false);
    m_isLoading = true;
    m_statusLabel->setText("Downloading PDF...");
    emit statusMessage("Downloading PDF from Zotero...");

    // Create temporary file
    m_tempPdfFile = std::make_unique<QTemporaryFile>(
        QDir::temp().absoluteFilePath("zotero_XXXXXX.pdf"));

    if (!m_tempPdfFile->open()) {
        showError("Failed to create temporary file for PDF");
        return;
    }

    m_downloadedPdfPath = m_tempPdfFile->fileName();
    m_tempPdfFile->setAutoRemove(false); // Keep file after object destruction

    // API endpoint for attachment file
    QString url = QString("https://api.zotero.org/users/%1/items/%2/file")
                    .arg(m_userId)
                    .arg(attachmentKey);

    QNetworkRequest request{QUrl(url)};
    request.setRawHeader("Zotero-API-Version", "3");
    request.setRawHeader("Authorization", QString("Bearer %1").arg(m_apiKey).toUtf8());
    request.setAttribute(QNetworkRequest::RedirectPolicyAttribute,
                        QNetworkRequest::NoLessSafeRedirectPolicy);

    m_currentReply = m_networkManager->get(request);
    connect(m_currentReply, &QNetworkReply::finished, this, &ZoteroInputWidget::handlePdfDownloadReply);
}

void ZoteroInputWidget::handleCollectionsReply() {
    if (!m_currentReply) return;

    m_currentReply->deleteLater();

    if (m_currentReply->error() != QNetworkReply::NoError) {
        QString errorMsg = QString("Failed to fetch collections: %1")
                            .arg(m_currentReply->errorString());

        if (m_currentReply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt() == 403) {
            errorMsg = "Authentication failed. Please check your Zotero credentials in Settings.";
        }

        showError(errorMsg);
        m_currentReply = nullptr;
        return;
    }

    QByteArray data = m_currentReply->readAll();
    m_currentReply = nullptr;

    QJsonDocument doc = QJsonDocument::fromJson(data);
    if (doc.isArray()) {
        parseCollections(doc.array());
        m_statusLabel->setText(QString("Loaded %1 collections").arg(m_collections.size()));
    } else {
        showError("Invalid response format from Zotero API");
    }

    setUIEnabled(true);
    m_isLoading = false;
}

void ZoteroInputWidget::handleItemsReply() {
    if (!m_currentReply) return;

    m_currentReply->deleteLater();

    if (m_currentReply->error() != QNetworkReply::NoError) {
        showError(QString("Failed to fetch items: %1").arg(m_currentReply->errorString()));
        m_currentReply = nullptr;
        return;
    }

    QByteArray data = m_currentReply->readAll();
    m_currentReply = nullptr;

    QJsonDocument doc = QJsonDocument::fromJson(data);
    if (doc.isArray()) {
        parseItems(doc.array());

        // After parsing items, check each for PDF attachments
        for (auto& item : m_items) {
            checkItemAttachments(item);
        }

        m_statusLabel->setText(QString("Loaded %1 papers").arg(m_items.size()));
        m_papersCombo->setEnabled(m_items.size() > 0);
    } else {
        showError("Invalid response format from Zotero API");
    }

    setUIEnabled(true);
    m_isLoading = false;
}

void ZoteroInputWidget::handlePdfDownloadReply() {
    if (!m_currentReply) return;

    m_currentReply->deleteLater();

    if (m_currentReply->error() != QNetworkReply::NoError) {
        showError(QString("Failed to download PDF: %1").arg(m_currentReply->errorString()));
        m_currentReply = nullptr;
        m_downloadedPdfPath.clear();
        return;
    }

    // Write PDF data to temporary file
    QByteArray pdfData = m_currentReply->readAll();
    m_currentReply = nullptr;

    if (pdfData.isEmpty()) {
        showError("Downloaded PDF is empty");
        m_downloadedPdfPath.clear();
        return;
    }

    if (m_tempPdfFile && m_tempPdfFile->isOpen()) {
        m_tempPdfFile->write(pdfData);
        m_tempPdfFile->flush();
        m_tempPdfFile->close();

        // Verify the PDF is valid
        QPdfDocument testDoc;
        if (testDoc.load(m_downloadedPdfPath) != QPdfDocument::Error::None) {
            showError("Downloaded file is not a valid PDF");
            m_downloadedPdfPath.clear();
            return;
        }

        m_statusLabel->setText("PDF downloaded successfully");
        emit statusMessage("PDF ready for analysis");
        emit pdfReady(m_downloadedPdfPath);
        emit analyzeRequested();
    } else {
        showError("Failed to save PDF to temporary file");
        m_downloadedPdfPath.clear();
    }

    setUIEnabled(true);
    m_isLoading = false;
}

void ZoteroInputWidget::handleChildrenReply() {
    if (!m_currentReply) return;

    m_currentReply->deleteLater();

    if (m_currentReply->error() != QNetworkReply::NoError) {
        showError(QString("Failed to fetch attachments: %1").arg(m_currentReply->errorString()));
        m_currentReply = nullptr;
        return;
    }

    QByteArray data = m_currentReply->readAll();
    m_currentReply = nullptr;

    QJsonDocument doc = QJsonDocument::fromJson(data);
    if (doc.isArray()) {
        QJsonArray children = doc.array();
        QString pdfAttachmentKey;

        // Look for PDF attachment
        for (const auto& value : children) {
            QJsonObject obj = value.toObject();
            QJsonObject dataObj = obj["data"].toObject();

            QString itemType = dataObj["itemType"].toString();
            QString contentType = dataObj["contentType"].toString();

            if (itemType == "attachment" && contentType == "application/pdf") {
                pdfAttachmentKey = obj["key"].toString();
                break;
            }
        }

        if (!pdfAttachmentKey.isEmpty()) {
            m_currentItem.pdfAttachmentKey = pdfAttachmentKey;
            m_currentItem.hasPdf = true;
            m_statusLabel->setText("PDF attachment found");

            // Now download the PDF
            downloadPdf(m_currentItem.key, pdfAttachmentKey);
        } else {
            m_currentItem.hasPdf = false;
            showError("No PDF attachment found for this item");
        }
    } else {
        showError("Invalid response format from Zotero API");
    }

    setUIEnabled(true);
    m_isLoading = false;
}

void ZoteroInputWidget::checkItemAttachments(const ZoteroItem& item) {
    // Note: A more complete implementation would fetch children via API
    // For now, we'll need to fetch children when the user selects an item
    // This is called after parsing items but doesn't have attachment info yet
}

void ZoteroInputWidget::parseCollections(const QJsonArray& data) {
    m_collections.clear();
    m_collectionsCombo->clear();
    m_collectionsCombo->addItem("Select a collection...");

    for (const auto& value : data) {
        QJsonObject obj = value.toObject();
        QJsonObject dataObj = obj["data"].toObject();

        ZoteroCollection collection;
        collection.key = obj["key"].toString();
        collection.name = dataObj["name"].toString();
        collection.parentKey = dataObj["parentCollection"].toString();

        if (!collection.key.isEmpty() && !collection.name.isEmpty()) {
            m_collections.append(collection);
        }
    }

    // Sort collections by name
    std::sort(m_collections.begin(), m_collections.end(),
              [](const ZoteroCollection& a, const ZoteroCollection& b) {
                  return a.name.compare(b.name, Qt::CaseInsensitive) < 0;
              });

    // Add to combo box
    for (const auto& collection : m_collections) {
        m_collectionsCombo->addItem(formatCollectionName(collection));
    }
}

void ZoteroInputWidget::parseItems(const QJsonArray& data) {
    m_items.clear();
    m_papersCombo->clear();
    m_papersCombo->addItem("Select a paper...");

    for (const auto& value : data) {
        QJsonObject obj = value.toObject();
        QJsonObject dataObj = obj["data"].toObject();

        // Skip non-document items
        QString itemType = dataObj["itemType"].toString();
        if (itemType == "attachment" || itemType == "note") {
            continue;
        }

        ZoteroItem item;
        item.key = obj["key"].toString();
        item.title = dataObj["title"].toString();
        item.year = dataObj["date"].toString().left(4); // Extract year

        // Build authors string
        QJsonArray creators = dataObj["creators"].toArray();
        QStringList authorsList;
        for (const auto& creator : creators) {
            QJsonObject creatorObj = creator.toObject();
            QString lastName = creatorObj["lastName"].toString();
            if (!lastName.isEmpty()) {
                authorsList.append(lastName);
            }
        }
        item.authors = authorsList.join(", ");

        // Check for PDF attachments (simplified - would need children API call)
        QJsonObject meta = obj["meta"].toObject();
        int numChildren = meta["numChildren"].toInt();
        item.hasPdf = (numChildren > 0); // Assume at least one child might be PDF

        // For actual implementation, we'd need to fetch children and find PDF attachment
        // This is a placeholder - we'll set the attachment key when fetching children
        if (item.hasPdf) {
            item.pdfAttachmentKey = item.key; // Placeholder - should be actual attachment key
        }

        if (!item.key.isEmpty() && !item.title.isEmpty()) {
            m_items.append(item);
        }
    }

    // Sort items by year (descending) then title
    std::sort(m_items.begin(), m_items.end(),
              [](const ZoteroItem& a, const ZoteroItem& b) {
                  if (a.year != b.year) {
                      return a.year > b.year; // Newer first
                  }
                  return a.title.compare(b.title, Qt::CaseInsensitive) < 0;
              });

    // Add to combo box
    for (const auto& item : m_items) {
        m_papersCombo->addItem(formatPaperDisplay(item));
    }
}

QString ZoteroInputWidget::formatCollectionName(const ZoteroCollection& collection) const {
    // Could add indentation for subcollections if needed
    return collection.name;
}

QString ZoteroInputWidget::formatPaperDisplay(const ZoteroItem& item) const {
    QString display = item.title;

    if (!item.authors.isEmpty()) {
        display = QString("%1 - %2").arg(item.authors).arg(display);
    }

    if (!item.year.isEmpty()) {
        display = QString("[%1] %2").arg(item.year).arg(display);
    }

    if (!item.hasPdf) {
        display += " (No PDF)";
    }

    return display;
}

void ZoteroInputWidget::setUIEnabled(bool enabled) {
    m_refreshButton->setEnabled(enabled);
    m_collectionsCombo->setEnabled(enabled && m_collections.size() > 0);
    m_papersCombo->setEnabled(enabled && m_items.size() > 0);
    m_analyzeButton->setEnabled(enabled && m_papersCombo->currentIndex() > 0);
}

void ZoteroInputWidget::showError(const QString& error) {
    m_statusLabel->setText(QString("Error: %1").arg(error));
    emit errorOccurred(error);
    setUIEnabled(true);
    m_isLoading = false;

    QMessageBox::warning(this, "Zotero Error", error);
}

void ZoteroInputWidget::clearCollections() {
    m_collections.clear();
    m_collectionsCombo->clear();
    m_collectionsCombo->addItem("Select a collection...");
}

void ZoteroInputWidget::clearPapers() {
    m_items.clear();
    m_papersCombo->clear();
    m_papersCombo->addItem("Select a paper...");
    m_papersCombo->setEnabled(false);
    m_analyzeButton->setEnabled(false);
}

// Logging implementation
void ZoteroInputWidget::logToFile(const QString& message) {
    if (!m_logFile || !m_logFile->isOpen()) {
        return;
    }

    QTextStream stream(m_logFile);
    stream << QDateTime::currentDateTime().toString("[hh:mm:ss.zzz] ")
           << message << Qt::endl;
    stream.flush();
}

void ZoteroInputWidget::logRequest(const QString& method, const QString& url, const QByteArray& headers) {
    logToFile("----------------------------------------");
    logToFile(QString("REQUEST: %1 %2").arg(method, url));

    if (!headers.isEmpty()) {
        logToFile("Headers:");
        QStringList headerLines = QString::fromUtf8(headers).split('\n');
        for (const QString& line : headerLines) {
            if (!line.trimmed().isEmpty()) {
                logToFile("  " + line.trimmed());
            }
        }
    }
}

void ZoteroInputWidget::logResponse(int statusCode, const QByteArray& response) {
    logToFile(QString("RESPONSE: Status Code %1").arg(statusCode));

    if (!response.isEmpty()) {
        // Try to parse as JSON for prettier output
        QJsonDocument doc = QJsonDocument::fromJson(response);
        if (!doc.isNull()) {
            logToFile("Response Data (JSON):");
            logToFile(doc.toJson(QJsonDocument::Indented));
        } else {
            // Not JSON, log as is (but truncate if too long)
            QString responseStr = QString::fromUtf8(response);
            if (responseStr.length() > 5000) {
                responseStr = responseStr.left(5000) + "\n... (truncated)";
            }
            logToFile("Response Data:");
            logToFile(responseStr);
        }
    } else {
        logToFile("Response: (empty)");
    }
}

void ZoteroInputWidget::logError(const QString& error) {
    logToFile(QString("ERROR: %1").arg(error));
}